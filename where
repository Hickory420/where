#!/bin/bash
set -u
##Versions and Change Log as of v1.7.0
#VERSION=1.7.0 # CR # 10/01/2014 # Added a loop for multiple arguments.
                                 # Added color coded System Average Load checking.
                                 # Added color coded Partition Warnings.
#VERSION=1.7.1 # CR # 10/01/2014 # Added checking of the mail queue.
#VERSION=1.7.2 # CR # 13/01/2014 # Fixed the tabbed spacing.
#VERSION=1.7.3 # CR # 20/01/2014 # Added ability to check Uniface's backup logs using CL.
                                 # Fixed the coloring issue for the DISK_DISPLAY function.
#VERSION=1.8.0 # CR # 23/01/2014 # Added new function MAILQUEUE.
                                 # Asks if you want to move the dead emails out of the mail queue.
#VERSION=1.8.1 # CR # 31/01/2014 # Increased performance in the mail function.
#VERSION=1.8.2 # CR # 17/02/2014 # Added a more noticing 100% full for disks.
#VERSION=1.9.0 # CR # 17/02/2014 # Added new function REMOTE.
                                 # Parses of the ssh logs for break in attempts.
#VERSION=1.9.1 # CR # 24/02/2014 # Added parsing of the ssh logs for Accepted connections.
#VERSION=1.9.2 # CR # 25/03/2014 # Extended ssh log to all instead of the current ssh log e.g.:(/var/log/secure*).
#VERSION=1.9.3 # CR # 22/04/2014 # Fixed the 100% disk display coloring.
#VERSION=1.9.4 # CR # 22/04/2014 # Fixed "integer expression expected" error in DISK_DISPLAY.
#VERSION=1.9.5 # CR # 01/05/2014 # Fixed DSTAT. "--top-int" crashes on some servers.
#VERSION=1.9.6 # CR # 10/07/2014 # Removed the restriction for checking ext[3-4] & nfs file systems for the where -s option.
#VERSION=1.9.7 # CR # 10/07/2014 # Added https:// to the icanhazip.com. This helps alleviate proxy problems.
                                 # and now always shows the WAN when script is launched.
#VERSION=1.10.0 # CR # 17/07/2014 # Added two new functions ONLINE and ERRCHK. Added more error control logic.
                                  # Also added declare's against every variable. Needs to be cleaned up...
#VERSION=1.10.1 # CR # 17/07/2014 # Tidied up some code to make it flow nicely.
#VERSION=1.10.2 # CR # 23/07/2014 # Forced variables to be declared with shopt -s -o errexit nounset
#VERSION=1.10.3 # CR # 08/08/2014 # Turned off checking of public WAN IP when logging in... Too slow
                                  # Also added https to downloading dstat. This helps alleviate proxy problems.
#VERSION=1.10.4 # CR # 23/08/2014 # Added full path for ifconfig in GET_IP function to satisfy Cron. Plus a bit of tweakage.
#VERSION=1.10.5 # CR # 23/08/2014 # Fixed up calling of functions and quit MAILQUEUE if mailq is handled by exim.
#VERSION=1.10.6 # CR # 21/09/2014 # Checks and reads /var/log/auth.log as we as /var/log/secure for SSH logins.
#VERSION=1.10.7 # CR # 05/11/2014 # Added more uname info.
#VERSION=1.10.8 # CR # 05/11/2014 # Fixed ifconfig that had a ':' at the end of the ifcfg device name. Like in systemd Operating systems.
#VERSION=1.10.9 # CR # 12/02/2015 # The change above broke non-systemd operating systems. Now caters for both. Ping wait is now 2 instead of 5
#VERSION=1.11.0 # CR # 12/02/2015 # Added a CORES function to show information of the cores on the processor.
#VERSION=1.11.1 # CR # 28/10/2015 # Fixed devision by 0 in the CORES function.
#VERSION=1.11.2 # CR # 28/10/2015 # Removed the https:// from icanhazip.com because it started failing.
#VERSION=1.11.3 # CR # 13/01/2016 # Replaced the use of curl with "wget -q -O -" because it's the same thing and wget is more commonly installed.
                                  # Also updated the dstat link because it appears to no longer work, so I am hosting the tar file: http://ohcp.onehotchilipepper.com.au/dstat.tar.gz
#VERSION=1.11.4 # CR # 11/08/2016 # Replaced the tr for a sed in the network DEV interface names. Caters for Bonding and interfaces with multiple addresses.
#VERSION=1.11.5 # CR # 07/03/2017 # Found a working link for dstat, as well as his github. Using the tar file for the time being.
#VERSION=1.11.6 # CR # 07/03/2017 # Replaced "wget -q -O -" with curl for downloading dstat 
#VERSION=1.12.0 # CR # 09/06/2017 # Removes environment specific entries and prompts to run dstat if the load warning appears if shell is interactive (new INTERACTIVE function)
 VERSION=1.13.0 # CR # 09/06/2017 # Added new function FINDUSAGE
# Now version controlled by GIT. All future version notes will be in the commit messages.

shopt -s -o errexit #nounset
#shopt -s -o errexit nounset

## ToDo:
# Add -a --all to run all functions ?
# Add Function SHOW_USED_SPACE showing what is taking up the most space.
# Have SHOW_USED_SPACE called automatically when used space is above 90% or 95%
# Detect large listener logs $ORACLE_HOME/diag/tnslsnr/SITECODE/listener/trace/listener.log
# Fix up declarations!!!

##Vars
declare -r TODAY=`date +%Y-%m-%d`
declare -r TIME="date +%H-%M"
declare ORACLE_HOME
declare TNSNAMES

if [ -n ${ORACLE_HOME:-} ]; then
  [ -f "${ORACLE_HOME:-}/network/admin/tnsnames.ora" ] && TNSNAMES="${ORACLE_HOME}/network/admin/tnsnames.ora";
elif [ -f "$ORACLE_HOME/tnsnames.ora" ]; then
  TNSNAMES="$ORACLE_HOME/tnsnames.ora"
fi

declare -r HEADING="Partition\tFull\tFree\tSize\tType
---------\t----\t----\t----\t----"

#Colors
declare -r NORMAL="\033[00m"
declare -r OK="\033[1;32m"
declare -r WARNING="\033[1;33m"
declare -r CRITICAL="\033[1;31m"
declare -r REDBLACK="\033[41;30m"
#BLINK="\E[5m"
#BLINK="\E[25m"
#BLINK="\033[5m"
#BLINK="\e[5m"

##Functions

function INTERACTIVE(){
  case $- in
    *i*)	return 0 ;;
    *)	return 1 ;;
  esac
}

function FINDUSAGE(){
  local DIR=$1
  local RESULT; local DU
  local STOP="GO"
  [ "$DIR" = "/" ] && DIR=""

  until [ "$STOP" = "STOP" ]; do
    if [ -d "$DIR/" ]; then
      #DU=$(du --block-size=1M --summarize --one-file-system --exclude=/proc ${DIR}/* || killall "$THISSCRIPT")
      DU=$(du --block-size=1M --summarize --one-file-system --exclude=/proc ${DIR}/* || killall "du")
      RESULT=$(echo "$DU" | sort -nr | head -n1)
      DIR=$(echo "$RESULT" | awk '{print $2}')
      [ -d "$DIR/" ] && echo "$RESULT"
    else
      STOP="STOP"
    fi
  done
}

function CORES(){

  local -i SOCKETS=$(grep -w "physical id" /proc/cpuinfo | sort -u | wc -l)
  [ "${SOCKETS}" -eq 0 ] && SOCKETS="1"
  local -i CORES=$(grep -w "core id" /proc/cpuinfo | sort -u | wc -l)
  [ "${CORES}" -eq 0 ] && CORES="1"
  local -r MODEL=$(grep -w "model name" /proc/cpuinfo | sort -u | awk -F: '{print $2}')
  local -ir THREADS=$(grep -w "processor" /proc/cpuinfo | sort -u | wc -l)
  local -ir TOTAL_CORES=$(echo $((${SOCKETS}*${CORES})))
  local -ir THREADS_PER_CORE=$(echo $((${THREADS}/${TOTAL_CORES})))

  echo -e "ModelName\t: " $MODEL
  echo -e "Sockets\t\t: " $SOCKETS
  echo -e "Cores/Socket\t: " $CORES
  echo -e "Threads/Core\t: " $THREADS_PER_CORE
  echo -e "TotalCores\t: " $TOTAL_CORES
  echo -e "TotalThreads\t: " $THREADS

}

function ONLINE(){
  ping -c1 -w2 8.8.8.8 >/dev/null 2>&1
  return $?
}

function ERRCHK(){
  local -ir STATUS=$1
  local -r MSG=$2
  if [ $STATUS -ne 0 ]; then
    echo $MSG
    exit $STATUS
  fi
}

function GET_IP(){
  local GET_IP_ARG="$1"

  local DEV
  local IFCONFIG="/sbin/ifconfig"
  local IPA="/sbin/ip"
  if [ -x "$IFCONFIG" ]; then
    local NICS=$("$IFCONFIG" -a | grep ^[a-z] | cut -d" " -f 1)
    for DEV in $NICS; do
      DEV=$([ "${DEV:(-1)}" = ":" ] && echo "$DEV" | sed 's/:$//' || echo "$DEV") #If the last character is a : delete it.
      #local IP=$(/sbin/ifconfig "$DEV" | grep addr: | grep -v "inet6" | awk '{print $2}' | cut -d: -f2)
      local IP=$(/sbin/ifconfig "$DEV" | grep inet | grep -v inet6 | awk '{print $2}' )
      echo -en "$DEV:\t"
      if [ "$IP" ]; then
        if echo "$IP" | grep -q addr; then
          echo $(echo $IP | cut -d: -f2)
        else
          echo "$IP"
        fi
      else
          echo "Up, but no IP address"
      fi
    done
  elif [ -x "$IPA" ]; then
    local list=$(ip a | grep -w -e inet -e "^[0-9].*:" | awk '{print $2}')
    while read -r line; do 
        if echo "$line" | grep -q ":"; then 
            echo -en "${line}\t"
        else
            echo "$line"
        fi
    done < <(echo "$list")
  else
    echo "Unable to execute $IFCONFIG or $IPA"
    echo -e "LAN:\tUnavailable"
  fi

  echo -en "WAN:\t"
  if ONLINE; then
    if [ $GET_IP_ARG = "all" ]; then
      #local EXTIP=$(curl http://icanhazip.com 2>/dev/null)
      local EXTIP=$(wget -q -O - http://icanhazip.com 2>/dev/null)
      [ "$EXTIP" ] && echo "${EXTIP}" || echo "Failed. Err $?"
    else
      echo "Online"
    fi
  else
    echo "OFFLINE"
  fi
  #else
  #  local -r IPFILE="/etc/sysconfig/network-scripts/ifcfg-eth0"
  #  if [ -r "$IPFILE" ]; then
  #    local -r IP62=`grep IPADDR $IPFILE 2>/dev/null | awk -F= '{print $2}'`
  #    local -r IP55=`grep IPADDR $IPFILE 2>/dev/null | awk -F\" '{print $2}'`
  #    [ -n "$IP62" ] && IP=$IP62
  #    [ -n "$IP55" ] && IP=$IP55
  #    [ -n "$IP" ] && echo "$IP" #|| GET_IP all
  #  else
  #    GET_IP all
  #  fi
  #fi
}

function DISK_DISPLAY(){
  local LINE
  echo -e "$HEADING"
  echo -e "$DISK_SIZES" | \
  while read LINE ; do
    local PARTITION=$(echo "$LINE" | awk '{print $1}')
    local PERCENTS=$(echo "$LINE" | awk '{print $2"\t"$3"\t"$5"\t"$4}')
    local FULL=$(echo "$PERCENTS::3" | cut -d% -f1)
    if [ $(expr length $FULL) -ge 2 ]; then
      if [ "${PERCENTS::2}" -ge 80 -a "${PERCENTS::2}" -lt 90 ]; then #Add Yellow color if the percentage full is between 80-89
        local PERCENTS="${WARNING}${PERCENTS::3}${NORMAL}${PERCENTS:3}"
      elif [ "${PERCENTS::2}" -ge 90 -a "${FULL}" -lt 100 ]; then   #Add Bright Red Color if the percentage full is between 90-99
        local PERCENTS="${CRITICAL}${PERCENTS::3}${NORMAL}${PERCENTS:3}"  #${REDBLACK}<<<--- Not Good!!!${NORMAL}";
      elif [ "${PERCENTS::3}" = 100 ]; then                       #Add Bright Red Color if the percentage full is 100 and make it stand out.
        local PERCENTS="${CRITICAL}${PERCENTS::4}${NORMAL}${PERCENTS:4}\t${REDBLACK}<<<--- VERY BAD${NORMAL}";
      fi
    fi

    if [ "$PARTITION" ]; then
      local FORMAT=$(expr length $PARTITION)
      if [ "$FORMAT" -ge 8 ]; then #If the Partition column is greater than or equal to 8 characters, then add 1 tabbed space.
        local PARTITION="$(expr substr $PARTITION 1 15)" #limit the PARTITION string from 1 to 15 characters to make output look neater
        echo -e "${PARTITION}\t${PERCENTS}"
      else
        echo -e "${PARTITION}\t\t${PERCENTS}"
      fi
    fi
  done
}

function DISK_CHECK(){
  local DISK_CHECK_ARG="$1"
  local DISK_SIZES
  local -r DISK=$(df -hPTl | grep -v Avail | awk '{print $7" "$6" "$5" "$2" "$3}')
  if [ $DISK_CHECK_ARG = all ]; then
    #Prints disk usage in an easy to read format.
    DISK_SIZES=$(echo "$DISK")
    DISK_DISPLAY
  elif [ $DISK_CHECK_ARG = warn ]; then
    #Checks if disk space is between 80%-100% full, if so, show it...
    DISK_SIZES=$(echo "$DISK" | egrep "[8-9][0-9]%|100%")
    if [ "$DISK_SIZES" ]; then
      DISK_DISPLAY
    else
      return 1
    fi
  fi
}

function NODE (){
  [ ${TNSNAMES:-} ] \
  && grep $TNSNAMES -e ^[a-zA-Z] | grep -i -v -E "orcl|acr1" | cut -d\= -f1 | cut -d" " -f1 | head -n1 | tr [:upper:] [:lower:] 2>/dev/null\
  || hostname | cut -d. -f1
}

function REMOTE(){
  local AUTH_LOG="/var/log/auth.log"
  local SECURE_LOG="/var/log/secure"
  local SSH_LOG
  if [ -f "$AUTH_LOG" ]; then
    SSH_LOG="$AUTH_LOG"
  elif [ -f "$SECURE_LOG" ]; then
    SSH_LOG="$SECURE_LOG"
  else
    echo "Can not find $AUTH_LOG or $SECURE_LOG"
    return 2
  fi
  echo "Using $SSH_LOG*"
  local HEADER=" Tries \tIP Address\tUser\n------- ---------------\t----"
  if [ `whoami` = root ]; then
  #if [ -r "${SSH_LOG}" ]; then
      local FAIL=`awk 'gsub(".*sshd.*Failed password for (invalid user )?", "") {print $3 "\t" $1}' ${SSH_LOG}* | sort -k1,1 -k2n | uniq -c | sort -n | grep -v '(invalid'`
      local GOOD=`awk 'gsub(".*sshd.*Accept", "") {print $6"\t"$4}' ${SSH_LOG}* | sort -k1,1 -k2n | uniq -c | sort -n`
      local FAIL_SHOW=`if [ -n "$FAIL" ]; then echo "${FAIL}" | wc -l; echo -e "$HEADER"; echo "$FAIL"; else echo 0; fi`
      local GOOD_SHOW=`if [ -n "$GOOD" ]; then echo "${GOOD}" | wc -l; echo -e "$HEADER"; echo "$GOOD"; else echo 0; fi`
      echo "Failures: $FAIL_SHOW"
      echo "Accepted: $GOOD_SHOW"
    #else
    #  echo "${SSH_LOG} does not exist or is unreadable"
    #fi
  else
    echo "You must be root (or use sudo) to use this function."
  fi
}

function DSTAT(){

  local -r HOME_BIN="$HOME/bin"
  local -r DSTAT_BIN="$HOME_BIN/dstat"
  #local -r DSTAT_VERSION="0.7.2"
  #local -r DSTAT_LINK="https://dag.wieers.com/home-made/dstat/dstat-$DSTAT_VERSION.tar.bz2"
  #local -r DSTAT_LINK="https://github.com/dagwieers/dstat/archive/master.zip"
  local -r DSTAT_LINK="https://github.com/dagwieers/dstat/archive/0.7.3.tar.gz"
  if [ ! -d "$DSTAT_BIN" ] ; then
    echo "dstat for this script is not installed... Installing"
    if ONLINE; then
      which wget >/dev/null 2>&1
      ERRCHK $? "wget is not installed (used to download dstat)"
      [ ! -d $HOME_BIN ] && mkdir -p $HOME_BIN
      cd $HOME_BIN
      curl -s -k -L $DSTAT_LINK | tar xz
      #wget -q -O - $DSTAT_LINK 2>/dev/null | tar xz
      ERRCHK $? "Failed to download dstat: $DSTAT_LINK"
      #mv dstat-$DSTAT_VERSION dstat
      cd - >/dev/null
      echo "Done."
      echo
    else
      echo "OFFLINE: Can not install dstat."
    fi
  fi

  if [ -d "$DSTAT_BIN" ] ; then
    echo "You may need to expand your terminal window for this one..."
    echo "Press CTRL+c to exit"
    $DSTAT_BIN/dstat --top-bio-adv --top-childwait \
                     --top-cpu-adv --top-cputime \
                     --top-cputime-avg --top-int \
                     --top-io-adv --top-latency \
                     --top-latency-avg --top-mem \
                     --top-oom 2>/dev/null
    [ $? -ne 0 ] && \
    $DSTAT_BIN/dstat --top-bio-adv --top-childwait \
                     --top-cpu-adv --top-cputime \
                     --top-cputime-avg --top-io-adv \
                     --top-latency --top-latency-avg \
                     --top-mem --top-oom
    [ $? -ne 0 ] && \
    $DSTAT_BIN/dstat
  fi
  return $?

}

function SYSTEMLOAD(){
  local SYSTEMLOAD_ARG="${1:-}"
  local LOAD
  local -r PROCFILE="/proc/loadavg"
  local ONE
  local FIVE
  local FIFTEEN
  local SHOW
  [ $PROCFILE ] && LOAD=`cat $PROCFILE | cut -d\  -f1-3` || echo "$PROCFILE does not exist. Cannot show system load averages."
  if [ "$LOAD" ]; then
    #Want to use AWK to assign these variables in one command.
    ONE=`echo $LOAD | cut -d" " -f1`
    FIVE=`echo $LOAD | cut -d" " -f2`
    FIFTEEN=`echo $LOAD | cut -d" " -f3`
  else
    echo "$PROCFILE contains nothing." && exit 1
  fi

  local -i ONE_CHECK=`echo "${ONE}"|cut -d. -f1`
  local -i FIVE_CHECK=`echo "${FIVE}"|cut -d. -f1`
  local -i FIFTEEN_CHECK=`echo "${FIFTEEN}"|cut -d. -f1`
  local ANS
  #Setting colors
  SHOW="no"

  if [ $ONE_CHECK -eq 1 ]; then ONE="${WARNING}${ONE}${NORMAL}"; SHOW="yes";
  elif [ $ONE_CHECK -gt 1 ]; then ONE="${CRITICAL}${ONE}${NORMAL}"; SHOW="yes";
  fi

  if [ $FIVE_CHECK -eq 1 ]; then FIVE="${WARNING}${FIVE}${NORMAL}"; SHOW="yes";
  elif [ $FIVE_CHECK -gt 1 ]; then FIVE="${CRITICAL}${FIVE}${NORMAL}"; SHOW="yes";
  fi

  if [ $FIFTEEN_CHECK -eq 1 ]; then FIFTEEN="${WARNING}${FIFTEEN}${NORMAL}"; SHOW="yes";
  elif [ $FIFTEEN_CHECK -gt 1 ]; then FIFTEEN="${CRITICAL}${FIFTEEN}${NORMAL}"; SHOW="yes";
  fi

  [ "$SHOW" = yes -o "$SYSTEMLOAD_ARG" = all ] && \
  echo -e "System Load \n1min\t5min\t15min \n${ONE}\t${FIVE}\t${FIFTEEN}"
  
  if INTERACTIVE; then
    echo "Run dstat? [Y/n]"
    read ANS
    [ "$ANS" = "N" -o "$ANS" = "n" ] || DSTAT
  fi
  #[ $ONE_CHECK -gt 1 ] && DSTAT

  return $?
}

function MAILQUEUE(){
  local MAILQUEUE_ARG=$1
  if [ `whoami` = root ]; then
    local MQUEUE="/var/spool/mqueue"
    #GOINGTO=`mailq -qL | grep @ | grep -v -i deferred | sort | tr [:upper:] [:lower:] | uniq | awk '{print $1}'`
    if info mailq 2>/dev/null | cat - | head | grep -iq exim; then return 1; fi
    local TOTAL_FAILED_EMAILS=`mailq -qL | grep requests: | cut -d" " -f 3 | grep -v ^0`
    [ "$TOTAL_FAILED_EMAILS" ] || local TOTAL_FAILED_EMAILS=0
    if [ -d "$MQUEUE" ]; then
      local LIST=`find $MQUEUE -type f`
      local GOINGTO=`grep To:.*@ $MQUEUE/Qf* 2>/dev/null | cut -d" " -f2 | sed -e 's/<//g' -e 's/>//g' | sort | tr [:upper:] [:lower:] | uniq -c | sort -nr`
      local GOINGTO_COUNT=`echo "$GOINGTO" | grep @ | wc -l`
      #COMINGFROM=`grep From:.* $MQUEUE/Qf* 2>/dev/null | cut -d: -f3`
      #TO_FROM_LIST="/tmp/tfl"
      #rm $TO_FROM_LIST 2>/dev/null
      #if [ -n "$LIST" ]; then
      #  echo "$LIST" | grep "$MQUEUE/Qf" | \
      #  while read EMAIL; do
      #    #TO=`grep To:.*@ $EMAIL 2>/dev/null | cut -d" " -f2 | sed -e 's/<//g' -e 's/>//g' | sort -u | tr [:upper:] [:lower:]`
      #    TO=`grep To:.*@ $EMAIL 2>/dev/null | cut -d" " -f2 | head -1 | sed -e 's/<//g' -e 's/>//g'`
      #    FROM=`grep -e From:.*@ -e "Mail Delivery Subsystem" $EMAIL 2>/dev/null | cut -d" " -f2- | head -1 | sed -e 's/<//g' -e 's/>//g'`
      #    [ -n "${TO}" -a -z "${FROM}" ] && echo -e "${TO}\t\t\t${EMAIL:18}" >>"$TO_FROM_LIST"
      #    [ -z "${TO}" -a -n "${FROM}" ] && echo -e "\t\t\t${FROM}\t${EMAIL:18}" >>"$TO_FROM_LIST"
      #    [ -n "${TO}" -a -n "${FROM}" ] && echo -e "${TO}\t${FROM}\t${EMAIL:18}" >>"$TO_FROM_LIST"
      #    #[ "$TO" -a -z "$FROM" ] && echo && echo "$EMAIL" && echo -e "To:${TO}"
      #    #[ "$TO" -a "$FROM" ] && echo && echo "$EMAIL" && echo -e "To:${TO}\t\tFrom:${FROM}"
      #  done
      #  cat "$TO_FROM_LIST" | sort -s -n -k 1,1
      #fi
      #exit
      # Getting the age of the failed emails -- START
      local SECONDS=`date +%s`
      local O_EMAIL_FILE=`ls -tr $MQUEUE/Qf* 2>/dev/null | head -1`
      local N_EMAIL_FILE=`ls -t  $MQUEUE/Qf* 2>/dev/null | head -1`
      if [ -f "$O_EMAIL_FILE" -a -f "$N_EMAIL_FILE" ]; then
        local O_AGE_SECONDS=`stat -c %Z "$O_EMAIL_FILE"`
        local N_AGE_SECONDS=`stat -c %Z "$N_EMAIL_FILE"`
        local O_EMAIL_SECONDS=`echo $(($SECONDS - $O_AGE_SECONDS))`
        local N_EMAIL_SECONDS=`echo $(($SECONDS - $N_AGE_SECONDS))`
        local O_EMAIL=`echo $(($O_EMAIL_SECONDS/86400))`
        local N_EMAIL=`echo $(($N_EMAIL_SECONDS/86400))`
        local O_MSG="The oldest failed email is ${O_EMAIL} Days old"
        local N_MSG="The newest failed email is ${N_EMAIL} Days old"
      fi
      # Getting the age of the failed emails -- STOP

      if [ "$GOINGTO_COUNT" -gt 0 -a "$MAILQUEUE_ARG" != all -a -n "$TOTAL_FAILED_EMAILS" ]; then
        echo "$TOTAL_FAILED_EMAILS dead email(s) with $GOINGTO_COUNT unique email addresses."
        [ "$O_MSG" -a "$N_MSG" ] && echo "$O_MSG" && echo "$N_MSG"
      fi
      #List everything.
      if [ "$MAILQUEUE_ARG" = all ]; then
        #qf_EMAIL_COUNT=`ls "$MQUEUE"/qf* 2>/dev/null | wc -l`
        #QF_EMAIL_COUNT=`ls "$MQUEUE"/Qf* 2>/dev/null | wc -l`
        #DF_EMAIL_COUNT=`ls "$MQUEUE"/df* 2>/dev/null | wc -l`
        local qf_EMAIL_LIST=`echo "$LIST" | grep $MQUEUE/qf 2>/dev/null`
        local QF_EMAIL_LIST=`echo "$LIST" | grep $MQUEUE/Qf 2>/dev/null`
        local DF_EMAIL_LIST=`echo "$LIST" | grep $MQUEUE/df 2>/dev/null`
        local qf_EMAIL_COUNT=`echo "$qf_EMAIL_LIST" | wc -l`
        local QF_EMAIL_COUNT=`echo "$QF_EMAIL_LIST" | wc -l`
        local DF_EMAIL_COUNT=`echo "$DF_EMAIL_LIST" | wc -l`
        local QF_SERIAL=`for qf_file in $QF_EMAIL_LIST; do echo ${qf_file:20}; done`
        local DF_SERIAL=`for df_file in $DF_EMAIL_LIST; do echo ${df_file:20}; done`

        if [ "$QF_EMAIL_COUNT" -gt 1 ]; then
          if [ "$QF_EMAIL_COUNT" -a "$TOTAL_FAILED_EMAILS" -a "$QF_EMAIL_COUNT" -eq "$TOTAL_FAILED_EMAILS" ]; then
            echo "All $QF_EMAIL_COUNT emails in the queue are dead emails"
            echo "and none are queued to go out."
          elif [ "$QF_EMAIL_COUNT" -ne "$DF_EMAIL_COUNT" ]; then
            cd "$MQUEUE"
            echo
            echo "There are $QF_EMAIL_COUNT Queue files and $DF_EMAIL_COUNT Data files..."
            echo "This isn't exactly normal..."
            echo "The orphan files are:"
            local DIFF=`diff <(echo "$QF_SERIAL") <(echo "$DF_SERIAL") | awk '{print $2}'`
            local LS_DIFF=`for file in $DIFF; do ls *$file; done`
            echo "$LS_DIFF"
            cd - >/dev/null
          else
            echo "Total of $qf_EMAIL_COUNT email(s) processing in the queue,"
            echo "and $TOTAL_FAILED_EMAILS are dead email(s)."
          fi
        else
          echo "All good in the mail-hood..."
        fi
        if [ "$TOTAL_FAILED_EMAILS" -gt 0 ]; then
          echo
          read -p "Press Enter to see a list of email addresses"
          echo "They were intended for:
${GOINGTO}" | more
          echo "Would you like to move all failed emails from"
          #echo "or, "
          echo -n "$MQUEUE -> ${MQUEUE}.${TODAY} [y/N]"
          read ANS
          if [ "$ANS" = "Y" -o "$ANS" = "y" ]; then
            cd "$MQUEUE"
            service sendmail stop
            echo "Working... Please wait..."
            [ -d "${MQUEUE}.${TODAY}" ] || mkdir "${MQUEUE}.${TODAY}"
            for file in $QF_SERIAL; do
              if [ `ls *$file 2>/dev/null | wc -l` -eq 2 ]; then
                mv *$file "${MQUEUE}.${TODAY}"
              fi
            done
            service sendmail start
            cd - >/dev/null
            echo "Done"
            MAILQUEUE all
          else
            echo
            echo "Mail has been untouched."
          fi
        fi
      fi

    else
      echo "$MQUEUE directory does not exist."
    fi
  elif [ `whoami` != root -a "$MAILQUEUE_ARG" = all ]; then
    echo "You must run this switch as root"
    return 1
  fi
}

function SecondsToDaysHoursMinutesSeconds() {
  local seconds=$1
  local days=$(($seconds/86400))
  local seconds=$(($seconds-($days*86400) ))
  local hours=$(($seconds/3600))
  local seconds=$((seconds-($hours*3600) ))
  local minutes=$(($seconds/60))
  local seconds=$(( $seconds-($minutes*60) ))
  if [ $2 = "OLD" ]; then
    echo "The oldest email is ${days}D ${hours}H ${minutes}M ${seconds}S old"
  elif [ $2 = "NEW" ]; then
    echo "The newest email is ${days}D ${hours}H ${minutes}M ${seconds}S old"
  fi
}


function WHERE_AM_I(){
  echo
  NODE
  echo
  GET_IP lan
  echo
  uptime | cut -d, -f1 | awk '{print "Up: "$3" " $4}'
  uname -n; date; uname -mrs
  SYSTEMLOAD warn
  echo
  DISK_CHECK warn
  echo
  MAILQUEUE warn
  BACKUP warn
  return 0
}

function HELP(){
  echo "
  Help:

  v$VERSION
  where [ -b | -c | -d | -f [PATH] | -h | -i | -l | -m | -n | -r | -s | -v | -w ]

        -b | --backup     Check the backup status for a failure.
        -c | --cores      Shows information about the cores on the processor.
        -d | --dstat      Runs a dstat on the system.
  -f [PATH]| --findu [PATH]     Finds which directory is using the most space from provided PATH.
        -h | --help       This help/usage message.
        -i | --ipaddress  Get all ip addresses on this box.
        -l | --load       Shows the average system load.
        -m | --mail       Gives information on the mail queue of the system.
        -n | --node       Get the sitecode of the server.
        -r | --remote     Parse SSH logs to check who tried to/has logged in.
        -s | --space      The space and usage info of all partitions.
        -v | --version    The version of the script and exit.
        -w | --warning    Only show partitions in the warning range without host info.

  Example: You may also use multiple arguments at once.
  where -s -i -f [PATH] -l
  "
  return 1
}

##Script
declare THISSCRIPT=$(basename $0)
#Handle Arguments
declare ARGS=$@
if [ -z "$ARGS" ]; then
  WHERE_AM_I
elif [ -n "$ARGS" ]; then
  for ARG in $ARGS; do
    case $ARG in
      -b|--backup)
        BACKUP status
      ;;
      -c|--cores)
        CORES
      ;;
      -d|--dstat)
        DSTAT        
      ;;
      -f|--findu)
        shift 1
        if ! echo "$1" | grep -q ^-; then
          FINDUSAGE $1
        else
          echo "Please provide a path. eg: where -f $HOME"
        fi
        shift 1
      ;;
      -i|--ipaddress)
        GET_IP all
      ;;
      -l|--load)
        SYSTEMLOAD all
      ;;
      -m|--mail)
        MAILQUEUE all
      ;;
      -n|--node)
        NODE
      ;;
      -r|--remote)
        REMOTE
      ;;
      -s|--space)
        DISK_CHECK all
      ;;
      -v|--version)
        echo $VERSION
        exit $?
      ;;
      -w|--warning)
        DISK_CHECK warn
      ;;
      *)
        HELP
    esac
    shift 1
  done
fi

